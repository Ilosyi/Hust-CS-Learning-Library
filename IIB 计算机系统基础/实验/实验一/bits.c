#include "bits.h"
/*
 * CS:APP 数据实验
 *
 * <请在此处填写你的姓名和用户ID>
 *
 * bits.c - 包含你对实验的解决方案的源文件。
 *          这是你将提交给导师的文件。
 *
 * 警告：不要包含 <stdio.h> 头文件；它会干扰 dlc
 * 编译器。你仍然可以在不包含 <stdio.h> 的情况下使用 printf 进行调试，
 * 尽管你可能会收到编译器警告。通常来说，
 * 忽略编译器警告是不好的做法，但在这种情况下是可以的。
 */

#if 0
 /*
  * 学生须知：
  *
  * 第一步：仔细阅读以下说明。
  */

你将通过编辑此源文件中的函数集合来提供数据实验的解决方案。

整数编码规则：

将每个函数中的 "return" 语句替换为一行或多行实现该函数的 C 代码。你的代码
必须符合以下风格：

int Funct(arg1, arg2, ...) {
    /* 简要描述你的实现是如何工作的 */
    int var1 = Expr1;
    ...
        int varM = ExprM;

    varJ = ExprJ;
    ...
        varN = ExprN;
    return ExprR;
}

每个 "Expr" 是一个仅使用以下内容的表达式：
1. 0 到 255（0xFF）之间的整数常量，包括 0 和 255。你
不允许使用大常量，如 0xffffffff。
2. 函数参数和局部变量（无全局变量）。
3. 一元整数操作 !~
4. 二元整数操作 & ^| +<< >>

某些问题进一步限制了允许的操作符集。
每个 "Expr" 可能由多个操作符组成。你不受限于
每行一个操作符。

你被明确禁止：
1. 使用任何控制结构，如 if、do、while、for、switch 等。
2. 定义或使用任何宏。
3. 在此文件中定义任何额外的函数。
4. 调用任何函数。
5. 使用任何其他操作，如 && 、 || 、 - 或 ? :
    6. 使用任何形式的类型转换。
    7. 使用除 int 以外的任何数据类型。这意味着你
    不能使用数组、结构体或联合体。


    你可以假设你的机器：
    1. 使用 32 位整数的补码表示。
    2. 执行算术右移。
    3. 当整数移位超过字长时，行为不可预测。

    可接受的编码风格示例：
    /*
     * pow2plus1 - 返回 2^x + 1，其中 0 <= x <= 31
     */
    int pow2plus1(int x) {
    /* 利用移位计算 2 的幂 */
    return (1 << x) + 1;
}

/*
 * pow2plus4 - 返回 2^x + 4，其中 0 <= x <= 31
 */
int pow2plus4(int x) {
    /* 利用移位计算 2 的幂 */
    int result = (1 << x);
    result += 4;
    return result;
}

浮点数编码规则

对于需要你实现浮点操作的问题，
编码规则不那么严格。你可以使用循环和
条件控制。你可以使用 int 和 unsigned。
你可以使用任意的整数和无符号常量。

你被明确禁止：
1. 定义或使用任何宏。
2. 在此文件中定义任何额外的函数。
3. 调用任何函数。
4. 使用任何形式的类型转换。
5. 使用除 int 或 unsigned 以外的任何数据类型。这意味着你
不能使用数组、结构体或联合体。
6. 使用任何浮点数据类型、操作或常量。


注意事项：
1. 使用 dlc（数据实验检查器）编译器（在实验手册中描述）来
检查你的解决方案的合法性。
2. 每个函数都有一个允许使用的操作符（!~&^| +<< >>）
的最大数量。dlc 会检查最大操作符计数。注意 '=' 不被
计数；你可以随意使用它而不受惩罚。
3. 使用 btest 测试工具来检查你的函数的正确性。
4. 使用 BDD 检查器来正式验证你的函数。
5. 每个函数的最大操作符数量在
每个函数的头部注释中给出。如果实验说明中
的最大操作符数量与此文件中的不一致，以
此文件为准。

/*
 * 第二步：根据编码规则修改以下函数。
 *
 *   重要提示：为避免评分意外：
 *   1. 使用 dlc 编译器检查你的解决方案是否符合
 *      编码规则。
 *   2. 使用 BDD 检查器正式验证你的解决方案是否
 *      产生正确的答案。
 */

#endif
 /* 版权所有 (C) 1991-2014 自由软件基金会，Inc.
    此文件是 GNU C 库的一部分。

    GNU C 库是自由软件；你可以根据 GNU 较宽松的通用公共许可证的条款
    重新分发和/或修改它；版本 2.1，或（由你选择）任何更高版本。

    GNU C 库的发布是为了希望它有用，
    但不提供任何保证；甚至不暗示适用于特定用途的保证。
    更多细节请参阅 GNU 较宽松的通用公共许可证。

    你应该已经收到 GNU 较宽松的通用公共许可证的副本；
    如果没有，请参阅 <http://www.gnu.org/licenses/>。  */
    /* 此头文件与 features.h 分开，以便编译器可以在
       每次编译时隐式包含它。它本身不能包含 <features.h> 或任何其他
       包含 <features.h> 的头文件，因为隐式包含发生在任何
       在源文件中首次显式包含系统头文件之前定义的功能测试宏之前。
       GCC 知道此头文件的名称以便预包含它。  */
       /* glibc 的意图是支持 IEC 559 数学功能，实数
          和复数。如果 GCC（4.9 及更高版本）预定义的宏
          指定编译器意图可用，则使用它们来确定
          总体意图是否支持这些功能；否则，
          假设较旧的编译器有意支持这些功能，并
          默认定义这些宏。  */
          /* wchar_t 使用 ISO/IEC 10646（第二版，发布于 2011-03-15）/
             Unicode 6.0。  */
             /* 我们不支持 C11 <threads.h>。  */

/*
*   lsbZero - 将 x 的最低有效位设置为 0
*   示例：lsbZero(0x87654321) = 0x87654320
*   合法操作：! ~ & ^ | + << >>
*   最大操作数：5
*   难度：1
*/
int lsbZero(int x)
{
    return x & ~1;
}

/*
 * byteNot - 对字 x 的第 n 个字节进行位反转
 *   字节编号从 0（最低有效位）到 3（最高有效位）
 *   示例：getByteNot(0x12345678,1) = 0x1234A978
 *   合法操作：! ~ & ^ | + << >>
 *   最大操作数：6
 *   难度：2
 */
int byteNot(int x, int n)
{
    // 步骤1：计算字节偏移量（每个字节8位）
    int shift = n << 3;      // 等价于 n*8，消耗1个操作符（<<）

    // 步骤2：生成反转掩码（0xFF左移到目标字节位置）
    int mask = 0xFF << shift; // 消耗2个操作符（<<，常数0xFF不算操作）

    // 步骤3：使用异或操作反转目标字节
    return x ^ mask;         // 消耗1个操作符（^）
	
}
/*
 *   byteXor - 比较 x 和 y 的第 n 个字节，如果相同则返回 0，否则返回 1

 *   示例：byteXor(0x12345678, 0x87654321, 1) = 1

 *			  byteXor(0x12345678, 0x87344321, 2) = 0
 *   合法操作：! ~ & ^ | + << >>
 *   最大操作数：20
 *   难度：2
 */
int byteXor(int x, int y, int n)
{
	int shift = n << 3;
	int m1 = x & (0xFF << shift);
	int m2 = y & (0xFF << shift);
	return !!((m1 ^ m2)&(0xFF << shift));
}
/*
 *   logicalAnd - x && y
 *   合法操作：! ~ & ^ | + << >>
 *   最大操作数：20
 *   难度：3
 */
int logicalAnd(int x, int y)
{
    return 2;
}
/*
 *   logicalOr - x || y
 *   合法操作：! ~ & ^ | + << >>
 *   最大操作数：20
 *   难度：3
 */
int logicalOr(int x, int y)
{
    return 2;
}
/*
 * rotateLeft - 将 x 向左旋转 n 位
 *   可以假设 0 <= n <= 31
 *   示例：rotateLeft(0x87654321,4) = 0x76543218
 *   合法操作：~ & ^ | + << >> !
 *   最大操作数：25
 *   难度：3
 */
int rotateLeft(int x, int n)
{
    return 2;
}
/*
 * parityCheck - 如果 x 包含奇数个 1 则返回 1
 *   示例：parityCheck(5) = 0, parityCheck(7) = 1
 *   合法操作：! ~ & ^ | + << >>
 *   最大操作数：20
 *   难度：4
 */
int parityCheck(int x)
{
    return 2;
}
/*
 * mul2OK - 确定是否可以计算 2*x 而不溢出
 *   示例：mul2OK(0x30000000) = 1
 *             mul2OK(0x40000000) = 0
 *
 *   合法操作：~ & ^ | + << >>
 *   最大操作数：20
 *   难度：2
 */
int mul2OK(int x)
{
    return 2;
}
/*
 * mult3div2 - 乘以 3/2 并向 0 舍入，
 *   应完全复制 C 表达式 (x*3/2) 的效果，
 *   包括溢出行为。
 *   示例：mult3div2(11) = 16
 *             mult3div2(-9) = -13
 *             mult3div2(1073741824) = -536870912(溢出)
 *   合法操作：! ~ & ^ | + << >>
 *   最大操作数：12
 *   难度：2
 */
int mult3div2(int x)
{
    return 2;
}
/*
 * subOK - 确定是否可以计算 x-y 而不溢出
 *   示例：subOK(0x80000000,0x80000000) = 1,
 *            subOK(0x80000000,0x70000000) = 0,
 *   合法操作：! ~ & ^ | + << >>
 *   最大操作数：20
 *   难度：3
 */
int subOK(int x, int y)
{
    return 2;
}
/*
 * absVal - x 的绝对值
 *   示例：absVal(-1) = 1.
 *   你可以假设 -TMax <= x <= TMax
 *   合法操作：! ~ & ^ | + << >>
 *   最大操作数：10
 *   难度：4
 */
int absVal(int x)
{
    return 2;
}
/*
 * float_abs - 返回浮点参数 f 的绝对值的位级等效值
 *   参数和结果都作为 unsigned int 传递，但它们
 *   应被解释为单精度浮点值的位级表示。
 *   当参数为 NaN 时，返回参数。
 *   合法操作：任何整数/无符号操作，包括 ||, &&。也可以使用 if, while
 *   最大操作数：10
 *   难度：2
 */
unsigned float_abs(unsigned uf)
{
    return 2;
}
/*
 * float_f2i - 返回表达式 (int) f 的位级等效值
 *   用于浮点参数 f。
 *   参数作为 unsigned int 传递，但它
 *   应被解释为单精度浮点值的位级表示。
 *   任何超出范围的值（包括 NaN 和无穷大）应返回
 *   0x80000000u。
 *   合法操作：任何整数/无符号操作，包括 ||, &&。也可以使用 if, while
 *   最大操作数：30
 *   难度：4
 */
int float_f2i(unsigned uf)
{
    return 2;
}
