

---

### **lab1_1：系统调用**
**文件**：`kernel/strap.c` → `handle_syscall`
```c
static void handle_syscall(trapframe *tf) {
    tf->epc += 4;
    long ret = do_syscall(tf->regs.a0, tf->regs.a1, tf->regs.a2, tf->regs.a3,
                          tf->regs.a4, tf->regs.a5, tf->regs.a6, tf->regs.a7);
    tf->regs.a0 = ret;
}
```

---

### **lab1_2：异常处理**
**文件**：`kernel/machine/mtrap.c` → `handle_mtrap`
```c
case CAUSE_ILLEGAL_INSTRUCTION:
    handle_illegal_instruction();
    break;
```

---

### **lab1_3：中断处理**
**文件**：`kernel/strap.c` → `handle_mtimer_trap`
```c
static void handle_mtimer_trap() {
  sprint("Ticks %d\n", g_ticks);
  g_ticks++;
  write_csr(sip, 0);
}
```

---

### **lab1_challenge1：打印调用栈**
- **`user/user_lib.h`**：
  ```c
  int print_backtrace(int depth);
  ```
- **`user/user_lib.c`**：
  ```c
  int print_backtrace(int depth) {
    return do_user_call(SYS_user_backtrace, depth, 0, 0, 0, 0, 0, 0);
  }
  ```
- **`kernel/syscall.h`**：
  ```c
  #define SYS_user_backtrace (SYS_user_base + 2)
  ```
- **`kernel/process.h`**：
  ```c
  char app_name[128];
  ```
- **`kernel/elf.c`**（`load_bincode_from_host_elf`内）：
  ```c
  strcpy(p->app_name, arg_bug_msg.argv[0]);
  ```
- **`kernel/syscall.c`** → `sys_user_backtrace`


```c
#include "kernel/elf.h"
#include "spike_interface/spike_file.h"
#include "util/string.h" // 用于 strcmp

// ... existing code ...

// [辅助函数] 根据地址在符号表中查找并打印符号名
void print_symbol(spike_file_t *f, elf_sect_header *symtab, elf_sect_header *strtab, uint64_t addr) {
  elf_sym sym;
  // 遍历符号表中的每一个条目
  for (uint64_t off = 0; off < symtab->size; off += sizeof(sym)) {
    spike_file_pread(f, &sym, sizeof(sym), symtab->offset + off);
    
    // 检查符号类型是否为函数 (STT_FUNC = 2)。info 的低 4 位表示类型。
    if ((sym.info & 0xf) != 2) continue;

    // 检查地址是否在当前符号的范围内 [value, value + size)
    if (addr >= sym.value && addr < sym.value + sym.size) {
      char name[64];
      // 从字符串表中读取符号名
      // sym.name 是字符串表中的字节偏移量
      spike_file_pread(f, name, sizeof(name), strtab->offset + sym.name);
      name[63] = '\0'; // 确保字符串结束
      sprint("%s\n", name);
      return;
    }
  }
  sprint("???\n"); // 未找到符号
}

// [系统调用实现] 执行栈回溯
ssize_t sys_user_backtrace(int depth) {
  // 1. 打开当前进程对应的 ELF 文件
  spike_file_t *f = spike_file_open(current->app_name, O_RDONLY, 0);
  if (IS_ERR_VALUE(f)) {
    sprint("Failed to open ELF file: %s\n", current->app_name);
    return -1;
  }

  // 2. 读取 ELF Header
  elf_header ehdr;
  spike_file_pread(f, &ehdr, sizeof(ehdr), 0);

  // 3. 读取 Section Header String Table Header (为了查找 section 的名字)
  // shstrndx 是 section header string table 在 section header table 中的索引
  elf_sect_header shstrtab_hdr;
  spike_file_pread(f, &shstrtab_hdr, sizeof(shstrtab_hdr), ehdr.shoff + ehdr.shstrndx * ehdr.shentsize);

  // 读取 Section Header String Table 的内容到缓冲区
  char shstrtab_buf[4096]; 
  if (shstrtab_hdr.size > sizeof(shstrtab_buf)) {
      sprint("shstrtab too big\n");
      spike_file_close(f);
      return -1;
  }
  spike_file_pread(f, shstrtab_buf, shstrtab_hdr.size, shstrtab_hdr.offset);

  // 4. 遍历所有 Section Header，寻找 .symtab 和 .strtab
  elf_sect_header symtab_hdr, strtab_hdr;
  int found_symtab = 0, found_strtab = 0;

  for (int i = 0; i < ehdr.shnum; i++) {
    elf_sect_header shdr;
    spike_file_pread(f, &shdr, sizeof(shdr), ehdr.shoff + i * ehdr.shentsize);
    
    // shdr.name 是名字在 shstrtab_buf 中的偏移
    char *name = shstrtab_buf + shdr.name;
    if (strcmp(name, ".symtab") == 0) {
      symtab_hdr = shdr;
      found_symtab = 1;
    } else if (strcmp(name, ".strtab") == 0) {
      strtab_hdr = shdr;
      found_strtab = 1;
    }
  }

  if (!found_symtab || !found_strtab) {
    sprint("Symbol table or string table not found\n");
    spike_file_close(f);
    return -1;
  }
  
  // 5. 开始栈回溯
  // 获取当前的 Frame Pointer (s0)
  uint64_t fp = current->trapframe->regs.s0;
  
  // 特殊处理：do_user_call 的栈帧
  // 当前的 fp 指向的是 do_user_call 建立的栈帧。
  // 在 do_user_call 中，它保存了调用者（print_backtrace）的 s0 在 *(fp - 8) 的位置（根据反汇编观测，或实验指导提示）。
  // 注意：这里需要特别小心，标准的 prologue 是 s0 存放在 *(s0-16)，但 do_user_call 可能不是标准函数，或者是内联汇编导致的特殊结构。
  // 这里按照给出的解题思路：
  // 1. 初始 fp 指向 do_user_call 的栈帧
  // 2. *(fp - 8) 是 print_backtrace 的 fp (假设 do_user_call 保存 s0 在 -8(s0))
  fp = *(uint64_t*)(fp - 8);
  
  // 3. 现在 fp 指向 print_backtrace 的栈帧
  //    print_backtrace 是普通函数，遵循标准 prologue：
  //    ra (返回地址) 存放在 *(fp - 8)
  //    old_fp (上层调用者 f8 的 fp) 存放在 *(fp - 16)
  uint64_t ra = *(uint64_t*)(fp - 8);
  
  // 4. 获取 f8 的 fp，准备下一轮循环
  fp = *(uint64_t*)(fp - 16);

  // 打印第一层 (f8)
  print_symbol(f, &symtab_hdr, &strtab_hdr, ra);

  // 循环打印剩余层级 (f7, f6, ...)
  for (int i = 0; i < depth - 1; i++) {
    if (fp == 0) break; 
    ra = *(uint64_t*)(fp - 8);     // 获取本层函数的返回地址
    fp = *(uint64_t*)(fp - 16);    // 移动到上一层栈帧
    print_symbol(f, &symtab_hdr, &strtab_hdr, ra);
  }

  spike_file_close(f);
  return 0;
}

// 修改 do_syscall 进行分发
long do_syscall(long a0, long a1, long a2, long a3, long a4, long a5, long a6, long a7) {
  switch (a0) {
    // ... existing cases ...
    case SYS_user_backtrace:
      return sys_user_backtrace(a1);
    // ...
  }
}
```

---

### **lab2_1：虚实地址转换**
**文件**：`kernel/vmm.c` → `user_va_to_pa`
```c
void *user_va_to_pa(pagetable_t page_dir, void *va) {
  pte_t *pte = page_walk(page_dir, (uint64)va, 0);
  if (pte == NULL || !(*pte & PTE_V)) return NULL;
  return (void *)(PTE2PA(*pte) + ((uint64)va & (PGSIZE - 1)));
}
```

---

### **lab2_2：简单内存分配和回收**
**文件**：`kernel/vmm.c` → `user_vm_unmap`
```c
void user_vm_unmap(pagetable_t page_dir, uint64 va, uint64 size, int free) {
  for (uint64 a = va; a < va + size; a += PGSIZE) {
    pte_t *pte = page_walk(page_dir, a, 0);
    if (pte != NULL && (*pte & PTE_V)) {
      if (free) free_page( (void *)PTE2PA(*pte) );
      *pte = 0;
    }
  }
}
```

---

### **lab2_3：缺页异常**
- **文件**：`kernel/strap.c` → `smode_trap_handler`
  ```c
  if (scause == CAUSE_USER_ECALL) { ... }
  else if (scause == CAUSE_STORE_PAGE_FAULT) {
    handle_user_page_fault(scause, stval);
  }
  ```
- **文件**：`kernel/strap.c` → `handle_user_page_fault`
  ```c
  void handle_user_page_fault(uint64 scause, uint64 stval) {
    void *pa = alloc_page();
    user_vm_map(current->pagetable, ROUNDDOWN(stval, PGSIZE), PGSIZE, (uint64)pa, 
                prot_to_type(PROT_READ | PROT_WRITE, 1));
  }
  ```

---

### **lab2_challenge1：复杂缺页异常**
**文件**：`kernel/strap.c` → `handle_user_page_fault`
```c
// kernel/strap.c

#include "kernel/riscv.h"
#include "kernel/process.h"
#include "kernel/pmm.h"
#include "kernel/vmm.h"
#include "spike_interface/spike_utils.h"
#include "util/functions.h"

// 声明外部函数，用于终止进程
extern ssize_t sys_user_exit(uint64 code);

void handle_user_page_fault(uint64 mcause, uint64 sepc, uint64 stval) {
  sprint("handle_page_fault: %lx\n", stval);
  switch (mcause) {
    case CAUSE_STORE_PAGE_FAULT:
      // 定义栈的合法增长范围，例如 USER_STACK_TOP 以下 20 页
      // 栈顶地址在 kernel/memlayout.h 中定义为 0x7ffff000
      if (stval < USER_STACK_TOP && stval > (USER_STACK_TOP - 20 * PGSIZE)) {
          // ==================== 合法栈扩展逻辑 (Lab2_3) ====================
          // 1. 分配物理页
          void* pa = alloc_page();
          if (pa == 0) panic("Out of memory!");

          // 2. 对齐虚拟地址到页边界
          uint64 map_va = stval - (stval % PGSIZE);

          // 3. 建立映射
          user_vm_map((pagetable_t)current->pagetable, map_va, PGSIZE, (uint64)pa,
                      prot_to_type(PROT_WRITE | PROT_READ, 1));
      } else {
          // ==================== 非法地址访问逻辑 (Challenge1) ====================
          // 如果地址不在栈增长范围内，则视为非法访问（如数组越界）
          sprint("this address is not available!\n");
          
          // 终止进程，退出码设为 -1 (根据预期输出)
          sys_user_exit(-1);
      }
      break;
      
    default:
      sprint("unknown page fault.\n");
      break;
  }
}
```

---

### **lab3_1：进程创建(fork)**
**文件**：`kernel/process.c` → `do_fork`
```c
case CODE_SEGMENT:
  for (uint64 va = parent->mapped_info[i].va; 
       va < parent->mapped_info[i].va + parent->mapped_info[i].size; va += PGSIZE) {
    pte_t *pte = page_walk(parent->pagetable, va, 0);
    user_vm_map(child->pagetable, va, PGSIZE, PTE2PA(*pte), 
                prot_to_type(PROT_READ | PROT_EXEC, 1));
  }
  break;
case HEAP_SEGMENT: { // 添加大括号解决作用域报错
  int free_block_filter[MAX_HEAP_PAGES];
  // ...
} break;
```

---

### **lab3_2：进程 yield**
- **文件**：`kernel/syscall.c` → `sys_user_yield`
  ```c
  ssize_t sys_user_yield() {
    current->status = READY;
    insert_to_ready_queue(current);
    schedule();
    return 0;
  }
  ```
- **文件**：`kernel/syscall.c` → `do_syscall`
  ```c
  case SYS_user_yield: return sys_user_yield();
  ```

---

### **lab3_3：循环轮转调度**
- **文件**：`kernel/strap.c` → `rrsched`
  ```c
  void rrsched() {
    if (current->tick_count >= TIME_SLICE_LEN) {
      current->tick_count = 0;
      current->status = READY;
      insert_to_ready_queue(current);
      schedule();
    }
  }
  ```
- **文件**：`kernel/strap.c` → `handle_mtimer_trap`
  ```c
  static void handle_mtimer_trap() {
    // ... 原有计数代码 ...
    rrsched(); // 挂载调度钩子
  }
  ```

---

### **lab3_challenge1：进程等待和数据段复制**
**Step 1: 用户态库更新**

**`user/user_lib.h`**

```c
// ... 原有声明 ...
int wait(int pid); // [新增]
```

**`user/user_lib.c`**

```c
// ... include ...
#include "kernel/syscall.h" // 确保包含 SYS_user_wait

int wait(int pid) {
    return do_user_call(SYS_user_wait, pid, 0, 0, 0, 0, 0, 0);
}
```

**Step 2: 内核定义更新**

**`kernel/syscall.h`**

```c
#define SYS_user_wait 20 // [新增] 确保不与现有调用号冲突
```

**`kernel/process.h`**

```c
typedef struct process {
    // ... 原有字段 ...
    int64 waiting_pid; // [新增] 记录正在等待的子进程 PID (-1代表任意)
} process;
```

**Step 3: 实现数据段复制**

**`kernel/process.c` -> `do_fork`**

```c
      case DATA_SEGMENT:
        // 遍历父进程数据段的每一页
        for (int j = 0; j < parent->mapped_info[i].npages; j++) {
            uint64 addr = parent->mapped_info[i].va + j * PGSIZE;
            
            // 1. 为子进程分配新的物理页 (Deep Copy 核心)
            char *page = alloc_page();
            
            // 2. 将父进程该页的数据完全拷贝到新页中
            memcpy(page, (void *)lookup_pa(parent->pagetable, addr), PGSIZE);
            
            // 3. 将新页映射到子进程的页表 (可读写，用户态)
            user_vm_map(child->pagetable, addr, PGSIZE, (uint64)page,
                        prot_to_type(PROT_WRITE | PROT_READ, 1));
        }

        // 注册映射信息
        child->mapped_info[child->total_mapped_region].va = parent->mapped_info[i].va;
        child->mapped_info[child->total_mapped_region].npages = parent->mapped_info[i].npages;
        child->mapped_info[child->total_mapped_region].seg_type = DATA_SEGMENT;
        child->total_mapped_region++;
        break;
```

**Step 4: 实现 Wait 和 Exit (核心逻辑)**

**`kernel/syscall.c`**

```c
#include "kernel/syscall.h"
#include "kernel/process.h"
#include "kernel/sched.h"

// [新增] 声明外部变量，修复编译错误
extern process procs[NPROC]; 
extern void insert_to_ready_queue(process* proc);
// [新增] sys_user_wait 实现
ssize_t sys_user_wait(ssize_t pid) {
    int has_child = 0;
    // 遍历所有进程寻找子进程
    for (int i = 0; i < NPROC; i++) {
        if (procs[i].parent == current) {
            // 匹配 PID (-1 或 指定PID)
            if (pid == -1 || procs[i].pid == pid) {
                has_child = 1;
                // 如果发现僵尸子进程，直接回收
                if (procs[i].status == ZOMBIE) {
                    procs[i].status = FREE;
                    return procs[i].pid;
                }
            }
        }
    }
    // 如果有子进程但都在运行，父进程阻塞
    if (has_child) {
        current->status = BLOCKED;
        current->waiting_pid = pid;
        schedule(); // 让出 CPU
        return 0;   // 返回值将被唤醒时的 a0 覆盖
    }

    return -1;
}
// [修改] sys_user_exit 实现 (修复唤醒逻辑)
ssize_t sys_user_exit(uint64 code) {
    sprint("User exit with code:%d.\n", code);

    current->status = ZOMBIE;

    // 检查父进程是否在等待
    if (current->parent && current->parent->status == BLOCKED) {
        int64 wait_pid = current->parent->waiting_pid;
        
        if (wait_pid == -1 || wait_pid == current->pid) {
            // 1. 唤醒父进程
            current->parent->status = READY;
            // 2. 设置父进程 wait 的返回值
            current->parent->trapframe->regs.a0 = current->pid;           
            // 3. [关键修复] 将父进程放回就绪队列！
            //// 缺少这一步会导致 schedule() 找不到父进程，从而报 "ready queue empty" 错误
            insert_to_ready_queue(current->parent);
            // 4. 回收自己
            current->status = FREE;
        }
    }
    schedule();
    return 0;
}
// [修改] do_syscall 添加分发
long do_syscall(...) {
    switch (a0) {
        // ... 其他 case ...
        case SYS_user_wait:
            return sys_user_wait(a1);
        // ...
    }
}
```

---

### **lab4_1：文件操作**
**文件**：`kernel/rfs.c` → `rfs_create`
```c
// kernel/rfs.c

struct vinode *rfs_create(struct vinode *parent, struct dentry *sub_dentry) {
  // ... (省略前面的代码)

  if (free_dinode == NULL)
    panic("rfs_create: no more free disk inode, we cannot create file.\n" );

  // initialize the states of the file being created

  // 移除 panic，初始化 dinode
  free_dinode->size = 0;
  free_dinode->type = R_FILE; // R_FILE 定义在 kernel/rfs.h
  free_dinode->nlinks = 1;
  free_dinode->blocks = 1;

  // DO NOT REMOVE ANY CODE BELOW.
  // allocate a free block for the file
  free_dinode->addrs[0] = rfs_alloc_block(parent->sb);

  // ... (省略后面的代码)
}
```

---

### **lab4_2：目录文件**
- **文件**：`kernel/rfs.c` → `rfs_readdir`
  ```c
  struct rfs_direntry *p_direntry = (struct rfs_direntry *)dir->dir_cache + dir->offset;
  strcpy(dir->name, p_direntry->name);
  dir->inum = p_direntry->inum;
  ```
- **文件**：`kernel/process.c` → `alloc_process` (适配评测)
  ```c
  // 将 total_mapped_region 从 4 改为 3，并注释掉 HEAP_SEGMENT 的初始化
  p->total_mapped_region = 3; 
  // p->mapped_info[HEAP_SEGMENT].va = ...
  ```

---

### **lab4_3：硬链接**
**文件**：`kernel/rfs.c` → `rfs_link`
```c
link_node->nlinks++;
rfs_add_direntry(parent, sub_dentry->name, link_node->inum);
rfs_write_dinode(link_node); // 持久化写入磁盘
```

---

### **lab4_challenge1：相对路径**
#### (1) 修改 vfs.c

首先引入 `process.h` 以访问当前进程信息。

**修改 `lookup_final_dentry`** 以支持 `.` 和 `..`：
```c
// kernel/vfs.c

struct dentry *lookup_final_dentry(const char *path, struct dentry **parent,
                                   char *miss_name) {
  // ... (省略部分代码)
  char *token = strtok(path_copy, "/");
  struct dentry *this = *parent;

  while (token != NULL) {
    // 处理 "."
    if (strcmp(token, ".") == 0) {
      token = strtok(NULL, "/");
      continue;
    }
    // 处理 ".."
    if (strcmp(token, "..") == 0) {
      if (this->parent != NULL)
        this = this->parent;
      token = strtok(NULL, "/");
      continue;
    }
    
    *parent = this;
    this = hash_get_dentry((*parent), token);
    // ... (后续逻辑不变)
```

**修改 VFS 接口** (`vfs_open`, `vfs_opendir`, `vfs_mkdir`, `vfs_link`, `vfs_unlink`)，根据路径首字符决定起点：
```c
// kernel/vfs.c

// 以 vfs_open 为例，其他函数类似
struct file *vfs_open(const char *path, int flags) {
  struct dentry *parent = vfs_root_dentry; 
  // 如果不是绝对路径，则从 cwd 开始
  if (path[0] != '/') {
    parent = current->pfiles->cwd;
  }
  // ...
```

#### (2) 修改 proc_file.c

实现 `do_rcwd`（反向遍历 dentry 树构建路径）和 `do_ccwd`（打开目录并更新 cwd）：

```c
// kernel/proc_file.c

// 读取当前工作目录
int do_rcwd(char *path) {
  struct dentry *d = current->pfiles->cwd;
  char buf[MAX_PATH_LEN];
  int pos = MAX_PATH_LEN - 1;
  buf[pos] = '\0';

  if (d == vfs_root_dentry) {
      strcpy(path, "/");
      return 0;
  }

  // 向上回溯直到根目录
  while (d != vfs_root_dentry && d != NULL) {
      int len = strlen(d->name);
      pos -= len;
      if (pos < 0) return -1;
      memcpy(buf + pos, d->name, len);
      
      pos--;
      if (pos < 0) return -1;
      buf[pos] = '/';
      
      d = d->parent;
  }
  strcpy(path, buf + pos);
  return 0;
}

// 切换当前工作目录
int do_ccwd(char *path) {
  struct file *dir_file = vfs_opendir(path);
  if (dir_file == NULL) {
    sprint("do_ccwd: cannot open directory %s\n", path);
    return -1;
  }
  
  struct dentry *old_cwd = current->pfiles->cwd;
  struct dentry *new_cwd = dir_file->f_dentry;
  
  // 更新引用计数并切换 cwd
  new_cwd->d_ref++; 
  current->pfiles->cwd = new_cwd;
  
  // 关闭用于查找的文件句柄
  vfs_closedir(dir_file); 
  
  // 释放旧 cwd 的引用（通过构造假文件句柄调用 vfs_closedir）
  if (old_cwd != vfs_root_dentry) {
      struct file fake;
      fake.f_dentry = old_cwd;
      vfs_closedir(&fake);
  }
  
  return 0;
}
```

#### (3) 修改 syscall.h 和 syscall.c

添加系统调用号及分发逻辑：
```c
// kernel/syscall.h
#define SYS_user_rcwd   (SYS_user_base + 30)
#define SYS_user_ccwd   (SYS_user_base + 31)
```

```c
// kernel/syscall.c
ssize_t sys_user_rcwd(char *pathva){
  char *pathpa = (char*)user_va_to_pa((pagetable_t)(current->pagetable), (void*)pathva);
  return do_rcwd(pathpa);
}

ssize_t sys_user_ccwd(char *pathva){
  char *pathpa = (char*)user_va_to_pa((pagetable_t)(current->pagetable), (void*)pathva);
  return do_ccwd(pathpa);
}

// 在 do_syscall switch 中添加 case
```
