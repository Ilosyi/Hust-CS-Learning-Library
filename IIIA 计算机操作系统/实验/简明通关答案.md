

---

### **lab1_1：系统调用**
**文件**：`kernel/strap.c` → `handle_syscall`
```c
static void handle_syscall(trapframe *tf) {
    tf->epc += 4;
    long ret = do_syscall(tf->regs.a0, tf->regs.a1, tf->regs.a2, tf->regs.a3,
                          tf->regs.a4, tf->regs.a5, tf->regs.a6, tf->regs.a7);
    tf->regs.a0 = ret;
}
```

---

### **lab1_2：异常处理**
**文件**：`kernel/machine/mtrap.c` → `handle_mtrap`
```c
case CAUSE_ILLEGAL_INSTRUCTION:
    handle_illegal_instruction();
    break;
```

---

### **lab1_3：中断处理**
**文件**：`kernel/strap.c` → `handle_mtimer_trap`
```c
static void handle_mtimer_trap() {
  sprint("Ticks %d\n", g_ticks);
  g_ticks++;
  write_csr(sip, 0);
}
```

---

### **lab1_challenge1：打印调用栈**
- **`user/user_lib.h`**：
  ```c
  int print_backtrace(int depth);
  ```
- **`user/user_lib.c`**：
  ```c
  int print_backtrace(int depth) {
    return do_user_call(SYS_user_backtrace, depth, 0, 0, 0, 0, 0, 0);
  }
  ```
- **`kernel/syscall.h`**：
  ```c
  #define SYS_user_backtrace (SYS_user_base + 2)
  ```
- **`kernel/process.h`**：
  ```c
  char app_name[128];
  ```
- **`kernel/elf.c`**（`load_bincode_from_host_elf`内）：
  ```c
  strcpy(p->app_name, arg_bug_msg.argv[0]);
  ```
- **`kernel/syscall.c`** → `sys_user_backtrace`（略，完整逻辑见原文）

---

### **lab2_1：虚实地址转换**
**文件**：`kernel/vmm.c` → `user_va_to_pa`
```c
void *user_va_to_pa(pagetable_t page_dir, void *va) {
  uint64 va_val = (uint64)va;
  pte_t *pte = page_walk(page_dir, va_val, 0);
  if (pte == 0 || (*pte & PTE_V) == 0) return NULL;
  uint64 pa_page = PTE2PA(*pte);
  uint64 offset = va_val & (PGSIZE - 1);
  return (void *)(pa_page + offset);
}
```

---

### **lab2_2：内存释放**
**文件**：`kernel/vmm.c` → `user_vm_unmap`
```c
void user_vm_unmap(pagetable_t page_dir, uint64 va, uint64 size, int free) {
  for (uint64 a = va; a < va + size; a += PGSIZE) {
    pte_t *pte = page_walk(page_dir, a, 0);
    if (pte == 0 || (*pte & PTE_V) == 0) continue;
    if (free) free_page((void *)PTE2PA(*pte));
    *pte = 0;
  }
}
```

---

### **lab2_3：缺页异常**
**文件**：`kernel/strap.c` → `handle_user_page_fault`
```c
void handle_user_page_fault(uint64 mcause, uint64 sepc, uint64 stval) {
  if (stval < USER_STACK_TOP && stval > (USER_STACK_TOP - 20 * PGSIZE)) {
    void* pa = alloc_page();
    if (pa == 0) panic("Out of memory! ");
    uint64 map_va = stval - (stval % PGSIZE);
    user_vm_map((pagetable_t)current->pagetable, map_va, PGSIZE, (uint64)pa,
                prot_to_type(PROT_WRITE | PROT_READ, 1));
  } else {
    sprint("this address is not available!\n");
    shutdown(-1);
  }
}
```

**同时修改 `smode_trap_handler`**：
```c
else if (cause == CAUSE_STORE_PAGE_FAULT || cause == CAUSE_LOAD_PAGE_FAULT) {
  handle_user_page_fault(cause, read_csr(sepc), read_csr(stval));
}
```

---

### **lab3_1：fork（代码段）**
**文件**：`kernel/process.c` → `do_fork` 中 `case CODE_SEGMENT`
```c
for (int j = 0; j < parent->mapped_info[i].npages; j++) {
  uint64 addr = parent->mapped_info[i].va + j * PGSIZE;
  uint64 pa = lookup_pa(parent->pagetable, addr);
  if (pa == 0) panic("Code segment page not found! ");
  user_vm_map(child->pagetable, addr, PGSIZE, pa,
              prot_to_type(PROT_READ | PROT_EXEC, 1));
}
```

---

### **lab3_2：yield**
**文件**：`kernel/syscall.c`
```c
ssize_t sys_user_yield() {
  current->status = READY;
  insert_to_ready_queue(current);
  schedule();
  return 0;
}

// 在 do_syscall 中添加：
case SYS_user_yield:
  return sys_user_yield();
```

---

### **lab3_3：轮转调度**
**文件**：`kernel/strap.c`
```c
void rrsched() {
  if (current->tick_count + 1 >= TIME_SLICE_LEN) {
    current->tick_count = 0;
    insert_to_ready_queue(current);
    schedule();
  } else {
    current->tick_count++;
  }
}

// 在 handle_mtimer_trap 末尾调用：
rrsched();
```

---

### **lab3_challenge1：数据段复制 + wait/exit**
- **`user/user_lib.h`**：
  ```c
  int wait(int pid);
  ```
- **`user/user_lib.c`**：
  ```c
  int wait(int pid) {
    return do_user_call(SYS_user_wait, pid, 0, 0, 0, 0, 0, 0);
  }
  ```
- **`kernel/syscall.h`**：
  ```c
  #define SYS_user_wait 20
  ```
- **`kernel/process.h`**：
  ```c
  int64 waiting_pid;
  ```
- **`kernel/process.c` → `do_fork` 中 `case DATA_SEGMENT`**：
  ```c
  for (int j = 0; j < parent->mapped_info[i].npages; j++) {
    uint64 addr = parent->mapped_info[i].va + j * PGSIZE;
    char *page = alloc_page();
    memcpy(page, (void *)lookup_pa(parent->pagetable, addr), PGSIZE);
    user_vm_map(child->pagetable, addr, PGSIZE, (uint64)page,
                prot_to_type(PROT_WRITE | PROT_READ, 1));
  }
  ```
- **`kernel/syscall.c`**（添加 `extern process procs[NPROC];`）
  ```c
  ssize_t sys_user_wait(ssize_t pid) {
    // 遍历 procs 找子进程，处理 ZOMBIE 或 BLOCKED
  }

  ssize_t sys_user_exit(uint64 code) {
    current->status = ZOMBIE;
    if (current->parent && current->parent->status == BLOCKED) {
      if (current->parent->waiting_pid == -1 || current->parent->waiting_pid == current->pid) {
        current->parent->status = READY;
        current->parent->trapframe->regs.a0 = current->pid;
        insert_to_ready_queue(current->parent);  // ⚠️关键修复
        current->status = FREE;
      }
    }
    schedule();
  }

  // do_syscall 中添加：
  case SYS_user_wait:
    return sys_user_wait(a1);
  ```

---

### **lab4_1：文件创建**
**文件**：`kernel/rfs.c` → `rfs_create`
```c
free_dinode->size = 0;
free_dinode->type = R_FILE;
free_dinode->nlinks = 1;
free_dinode->blocks = 1;
```

---

### **lab4_2：目录读取**
**文件**：`kernel/rfs.c` → `rfs_readdir`
```c
strcpy(dir->name, p_direntry->name);
dir->inum = p_direntry->inum;
```

---

### **lab4_3：硬链接**
**文件**：`kernel/rfs.c` → `rfs_link`
```c
link_node->nlinks++;
rfs_add_direntry(parent, sub_dentry->name, link_node->inum);
rfs_write_back_vinode(link_node);
```

---

### **lab4_challenge1：相对路径**
- **`vfs.c`**：`lookup_final_dentry` 中增加对 `"."` 和 `".."` 的判断。
- **VFS 接口**（如 `vfs_open`）起点改为：
  ```c
  struct dentry *parent = (path[0] == '/') ? vfs_root_dentry : current->pfiles->cwd;
  ```
- **`proc_file.c`**：实现 `do_rcwd`（路径拼接）和 `do_ccwd`（切换 cwd 并调用 `vfs_opendir`）。
- **`syscall.c`**：添加 `sys_user_rcwd` / `sys_user_ccwd` 并做 `user_va_to_pa` 转换。

--- 

